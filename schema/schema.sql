-- ============================================================
-- ultimate_2025_enhanced.db â€” full DDL
-- Generated by scripts/export.py
-- ============================================================

PRAGMA journal_mode = WAL;
PRAGMA foreign_keys = OFF;  -- re-enabled by build.py after bulk load


-- ---- TABLES ----

CREATE TABLE AdversarialTestCases (
  case_id INTEGER PRIMARY KEY,
  suite_id INTEGER NOT NULL,
  test_input TEXT NOT NULL,
  expected_output TEXT NOT NULL CHECK(json_valid(expected_output)),
  assertion_type TEXT NOT NULL CHECK(assertion_type IN ('exact_match','semantic_similarity','phonetic_distance','set_containment')),
  threshold REAL DEFAULT 1.0,
  tags TEXT CHECK(tags IS NULL OR json_valid(tags)),
  created_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP),
  FOREIGN KEY (suite_id) REFERENCES TestSuites(suite_id) ON DELETE CASCADE
);

CREATE TABLE AntonymCache (
  relationship_id INTEGER PRIMARY KEY,
  word_id INTEGER NOT NULL,
  antonym_word_id INTEGER NOT NULL,
  definition_id INTEGER,
  antonym_definition_id INTEGER,
  confidence REAL,
  metadata TEXT,
  FOREIGN KEY (relationship_id) REFERENCES SemanticRelationships(relationship_id) ON DELETE CASCADE,
  FOREIGN KEY (word_id) REFERENCES Words(word_id) ON DELETE CASCADE,
  FOREIGN KEY (antonym_word_id) REFERENCES Words(word_id) ON DELETE CASCADE
);

CREATE TABLE CompoundWordParts (
  compound_id INTEGER PRIMARY KEY,
  word_id INTEGER NOT NULL,
  component_word_id INTEGER NOT NULL,
  position INTEGER NOT NULL CHECK(position >= 0),
  is_modified INTEGER NOT NULL DEFAULT 0 CHECK(is_modified IN (0, 1)),
  modification TEXT,
  UNIQUE (word_id, component_word_id, position) ON CONFLICT ABORT,
  FOREIGN KEY (word_id) REFERENCES Words(word_id) ON DELETE CASCADE,
  FOREIGN KEY (component_word_id) REFERENCES Words(word_id) ON DELETE CASCADE,
  CHECK (word_id != component_word_id)
);

CREATE TABLE Definitions (
  definition_id INTEGER PRIMARY KEY,
  sense_id INTEGER NOT NULL,
  definition TEXT NOT NULL CHECK(length(definition) >= 10),
  definition_context TEXT,
  sequence_order INTEGER NOT NULL DEFAULT 0 CHECK(sequence_order >= 0),
  is_literal INTEGER NOT NULL DEFAULT 1 CHECK(is_literal IN (0, 1)),
  source TEXT,
  created_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP),
  updated_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP),
  UNIQUE (sense_id, definition) ON CONFLICT ABORT,
  FOREIGN KEY (sense_id) REFERENCES Senses(sense_id) ON DELETE CASCADE
);

CREATE TABLE Dialects (
  dialect_id INTEGER PRIMARY KEY,
  language_id INTEGER NOT NULL,
  dialect_code TEXT NOT NULL,
  dialect_name TEXT NOT NULL,
  region_id INTEGER,
  description TEXT,
  is_active INTEGER NOT NULL DEFAULT 1 CHECK(is_active IN (0, 1)),
  UNIQUE(language_id, dialect_code) ON CONFLICT ABORT,
  UNIQUE(language_id, dialect_name) ON CONFLICT ABORT,
  FOREIGN KEY (language_id) REFERENCES Languages(language_id) ON DELETE RESTRICT,
  FOREIGN KEY (region_id) REFERENCES Regions(region_id) ON DELETE SET NULL
);

CREATE TABLE DistinctiveFeatures (
  feature_id INTEGER PRIMARY KEY,
  feature_name TEXT NOT NULL UNIQUE,
  feature_group TEXT NOT NULL,
  value_min REAL,
  value_max REAL,
  description TEXT
);

CREATE TABLE EmbeddingModels (
  model_id INTEGER PRIMARY KEY,
  model_name TEXT NOT NULL UNIQUE,
  provider TEXT,
  model_version TEXT,
  dimensions INTEGER NOT NULL CHECK(dimensions > 0),
  distance_metric TEXT NOT NULL CHECK(distance_metric IN ('cosine','dot','l2')),
  is_active INTEGER NOT NULL DEFAULT 1 CHECK(is_active IN (0, 1)),
  created_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP)
);

CREATE TABLE G2PAlignments (
  alignment_id INTEGER PRIMARY KEY,
  variant_id INTEGER NOT NULL,
  grapheme_start_index INTEGER NOT NULL CHECK(grapheme_start_index >= 0),
  grapheme_length INTEGER NOT NULL CHECK(grapheme_length >= 0),
  phoneme_seq_start INTEGER,
  phoneme_seq_len INTEGER NOT NULL CHECK(phoneme_seq_len >= 0),
  confidence_score REAL CHECK(confidence_score BETWEEN 0 AND 1),
  is_manual_verification INTEGER NOT NULL DEFAULT 0 CHECK(is_manual_verification IN (0, 1)),
  CHECK(
    (phoneme_seq_len = 0 AND phoneme_seq_start IS NULL)
    OR
    (phoneme_seq_len > 0 AND phoneme_seq_start IS NOT NULL AND phoneme_seq_start >= 0)
  ),
  FOREIGN KEY (variant_id) REFERENCES Variants(variant_id) ON DELETE CASCADE,
  UNIQUE(variant_id, grapheme_start_index) ON CONFLICT REPLACE
);

CREATE TABLE IpaAllowedChars (
  ch TEXT PRIMARY KEY CHECK(length(ch) = 1)
);

CREATE TABLE Languages (
  language_id INTEGER PRIMARY KEY,
  language_code TEXT NOT NULL UNIQUE,
  language_name TEXT NOT NULL UNIQUE,
  writing_direction TEXT NOT NULL CHECK(writing_direction IN ('LTR', 'RTL', 'TTB')),
  is_active INTEGER NOT NULL DEFAULT 1 CHECK(is_active IN (0, 1)),
  created_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP),
  updated_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP)
);

CREATE TABLE MaintenanceLogs (
  log_id INTEGER PRIMARY KEY,
  operation_type TEXT NOT NULL CHECK(operation_type IN ('BACKUP', 'VACUUM', 'REINDEX', 'INTEGRITY_CHECK', 'CUSTOM')),
  operation_details TEXT,
  start_time TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP),
  end_time TEXT,
  success INTEGER CHECK(success IN (0, 1)),
  error_message TEXT
);

CREATE TABLE MorphologicalForms (
  form_id INTEGER PRIMARY KEY,
  word_id INTEGER NOT NULL,
  form_type TEXT NOT NULL CHECK(form_type IN (
    'plural','singular','past','present','future',
    'infinitive','participle','gerund','comparative','superlative',
    'diminutive','augmentative','nominative','accusative','genitive',
    'dative','instrumental','prepositional','locative','vocative',
    'masculine','feminine','neuter','first_person','second_person',
    'third_person','subjunctive','imperative','conditional'
  )),
  form_text TEXT NOT NULL,
  is_regular INTEGER NOT NULL CHECK(is_regular IN (0, 1)),
  notes TEXT,
  UNIQUE (word_id, form_type) ON CONFLICT REPLACE,
  FOREIGN KEY (word_id) REFERENCES Words(word_id) ON DELETE CASCADE
);

CREATE TABLE PartOfSpeech (
  pos_id INTEGER PRIMARY KEY,
  pos_name TEXT NOT NULL UNIQUE CHECK(length(pos_name) >= 2),
  pos_abbreviation TEXT NOT NULL,
  language_id INTEGER NOT NULL,
  description TEXT, is_active INTEGER NOT NULL DEFAULT 1,
  FOREIGN KEY (language_id) REFERENCES Languages(language_id) ON DELETE RESTRICT
);

CREATE TABLE PhonemeCategories (
  category_id INTEGER PRIMARY KEY,
  category_name TEXT NOT NULL UNIQUE CHECK(category_name IN (
    'vowel','consonant','diphthong','semivowel','suprasegmental',
    'affricate','fricative','nasal','stop','approximant','lateral',
    'trill','flap','click','implosive','ejective'
  ))
);

CREATE TABLE PhonemeFeatureValues (
  phoneme_id INTEGER NOT NULL,
  feature_id INTEGER NOT NULL,
  value_num REAL NOT NULL,
  PRIMARY KEY (phoneme_id, feature_id) ON CONFLICT REPLACE,
  FOREIGN KEY (phoneme_id) REFERENCES Phonemes(phoneme_id) ON DELETE CASCADE,
  FOREIGN KEY (feature_id) REFERENCES DistinctiveFeatures(feature_id) ON DELETE CASCADE
) WITHOUT ROWID;

CREATE TABLE Phonemes (
  phoneme_id INTEGER PRIMARY KEY,
  ipa_symbol TEXT NOT NULL UNIQUE CHECK(length(ipa_symbol) > 0),
  category_id INTEGER NOT NULL,
  articulatory_description TEXT,
  language_specific INTEGER NOT NULL DEFAULT 0 CHECK(language_specific IN (0, 1)),
  language_id INTEGER,
  created_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP),
  FOREIGN KEY (category_id) REFERENCES PhonemeCategories(category_id) ON DELETE RESTRICT,
  FOREIGN KEY (language_id) REFERENCES Languages(language_id) ON DELETE SET NULL
);

CREATE TABLE Regions (
  region_id INTEGER PRIMARY KEY,
  region_code TEXT UNIQUE,
  region_name TEXT NOT NULL UNIQUE,
  parent_region_id INTEGER,
  description TEXT,
  is_active INTEGER NOT NULL DEFAULT 1 CHECK(is_active IN (0, 1)),
  FOREIGN KEY (parent_region_id) REFERENCES Regions(region_id) ON DELETE SET NULL
);

CREATE TABLE RegisterTypes (
  register_id INTEGER PRIMARY KEY,
  register_name TEXT NOT NULL UNIQUE CHECK(register_name IN (
    'formal','informal','archaic','slang','technical','poetic',
    'vulgar','colloquial','dialectal','regional','literary'
  )),
  description TEXT
);

CREATE TABLE RhymePatterns (
                        rhyme_id INTEGER PRIMARY KEY,
                        variant_id INTEGER NOT NULL,
                        rhyme_segment TEXT,
                        rhyme_arpabet TEXT,
                        rhyme_ipa TEXT,
                        rhyme_type TEXT,
                        rhyme_onset_syllable INTEGER,
                        created_at TEXT,
                        FOREIGN KEY (variant_id) REFERENCES Variants(variant_id)
                    );

CREATE TABLE SchemaMetadata (
  version TEXT PRIMARY KEY CHECK(version GLOB '[0-9]*.[0-9]*.[0-9]*'),
  deployed_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP),
  description TEXT,
  applied_by TEXT,
  checksum TEXT NOT NULL
);

CREATE TABLE SemanticRelationshipTypes (
  type_id INTEGER PRIMARY KEY,
  type_name TEXT NOT NULL UNIQUE CHECK(type_name IN (
    'synonym','antonym','hypernym','hyponym','holonym','meronym',
    'troponym','entailed_by','causes','similar_to','derived_from',
    'domain_of','part_of_speech_of','has_participle','pertainym',
    'attribute','also_see','verb_group'
  )),
  description TEXT,
  is_symmetric INTEGER NOT NULL DEFAULT 0 CHECK(is_symmetric IN (0, 1)),
  inverse_type_id INTEGER,
  FOREIGN KEY (inverse_type_id) REFERENCES SemanticRelationshipTypes(type_id) ON DELETE SET NULL
);

CREATE TABLE SemanticRelationships (
  relationship_id INTEGER PRIMARY KEY,
  source_word_id INTEGER NOT NULL,
  target_word_id INTEGER NOT NULL,
  type_id INTEGER NOT NULL,
  bidirectional INTEGER NOT NULL DEFAULT 0 CHECK(bidirectional IN (0, 1)),
  definition_specific INTEGER NOT NULL DEFAULT 0 CHECK(definition_specific IN (0, 1)),
  source_definition_id INTEGER,
  target_definition_id INTEGER,
  confidence REAL CHECK(confidence BETWEEN 0 AND 1),
  metadata TEXT CHECK(metadata IS NULL OR json_valid(metadata)),
  created_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP),
  FOREIGN KEY (source_word_id) REFERENCES Words(word_id) ON DELETE CASCADE,
  FOREIGN KEY (target_word_id) REFERENCES Words(word_id) ON DELETE CASCADE,
  FOREIGN KEY (type_id) REFERENCES SemanticRelationshipTypes(type_id) ON DELETE RESTRICT,
  FOREIGN KEY (source_definition_id) REFERENCES Definitions(definition_id) ON DELETE SET NULL,
  FOREIGN KEY (target_definition_id) REFERENCES Definitions(definition_id) ON DELETE SET NULL,
  CHECK(source_word_id != target_word_id)
);

CREATE TABLE SenseEmbeddings (
  sense_id INTEGER NOT NULL,
  model_id INTEGER NOT NULL,
  vector_blob BLOB NOT NULL,
  norm REAL,
  quantization TEXT CHECK(quantization IN ('none','fp16','int8','pq')) DEFAULT 'none',
  is_active INTEGER NOT NULL DEFAULT 1 CHECK(is_active IN (0, 1)),
  created_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP),
  PRIMARY KEY (sense_id, model_id) ON CONFLICT REPLACE,
  FOREIGN KEY (sense_id) REFERENCES Senses(sense_id) ON DELETE CASCADE,
  FOREIGN KEY (model_id) REFERENCES EmbeddingModels(model_id) ON DELETE RESTRICT
);

CREATE TABLE Senses (
  sense_id INTEGER PRIMARY KEY,
  variant_id INTEGER NOT NULL,
  sense_num INTEGER NOT NULL CHECK(sense_num >= 1),
  gloss TEXT,
  domain TEXT,
  register_id INTEGER,
  is_active INTEGER NOT NULL DEFAULT 1 CHECK(is_active IN (0, 1)),
  created_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP),
  UNIQUE (variant_id, sense_num) ON CONFLICT ABORT,
  FOREIGN KEY (variant_id) REFERENCES Variants(variant_id) ON DELETE CASCADE,
  FOREIGN KEY (register_id) REFERENCES RegisterTypes(register_id) ON DELETE SET NULL
);

CREATE TABLE SyllableInfo (
  variant_id INTEGER NOT NULL,
  syllable_type_id INTEGER NOT NULL,
  syllables TEXT NOT NULL,
  position INTEGER,
  stress_level INTEGER CHECK(stress_level BETWEEN 0 AND 3),
  notes TEXT,
  PRIMARY KEY (variant_id, syllable_type_id) ON CONFLICT REPLACE,
  FOREIGN KEY (variant_id) REFERENCES Variants(variant_id) ON DELETE CASCADE,
  FOREIGN KEY (syllable_type_id) REFERENCES SyllableTypes(syllable_type_id) ON DELETE CASCADE
);

CREATE TABLE SyllableTypes (
  syllable_type_id INTEGER PRIMARY KEY,
  syllable_type_name TEXT NOT NULL UNIQUE CHECK(syllable_type_name IN (
    'stress_pattern','final_syllable','final_two','final_three',
    'initial_syllable','medial','onset','nucleus','coda'
  ))
);

CREATE TABLE SynonymCache (
  relationship_id INTEGER PRIMARY KEY,
  word_id INTEGER NOT NULL,
  synonym_word_id INTEGER NOT NULL,
  definition_id INTEGER,
  synonym_definition_id INTEGER,
  confidence REAL,
  metadata TEXT,
  FOREIGN KEY (relationship_id) REFERENCES SemanticRelationships(relationship_id) ON DELETE CASCADE,
  FOREIGN KEY (word_id) REFERENCES Words(word_id) ON DELETE CASCADE,
  FOREIGN KEY (synonym_word_id) REFERENCES Words(word_id) ON DELETE CASCADE
);

CREATE TABLE TestCaseResults (
  result_id INTEGER PRIMARY KEY,
  run_id INTEGER NOT NULL,
  case_id INTEGER NOT NULL,
  passed INTEGER NOT NULL CHECK(passed IN (0, 1)),
  score REAL,
  observed_output TEXT CHECK(observed_output IS NULL OR json_valid(observed_output)),
  error TEXT,
  executed_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP),
  UNIQUE(run_id, case_id) ON CONFLICT REPLACE,
  FOREIGN KEY (run_id) REFERENCES TestRuns(run_id) ON DELETE CASCADE,
  FOREIGN KEY (case_id) REFERENCES AdversarialTestCases(case_id) ON DELETE CASCADE
);

CREATE TABLE TestRuns (
  run_id INTEGER PRIMARY KEY,
  suite_id INTEGER NOT NULL,
  started_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP),
  finished_at TEXT,
  environment TEXT,
  git_sha TEXT,
  runner TEXT,
  pass_rate REAL CHECK(pass_rate BETWEEN 0 AND 1),
  notes TEXT,
  FOREIGN KEY (suite_id) REFERENCES TestSuites(suite_id) ON DELETE CASCADE
);

CREATE TABLE TestSuites (
  suite_id INTEGER PRIMARY KEY,
  suite_name TEXT NOT NULL UNIQUE,
  description TEXT,
  target_module TEXT CHECK(target_module IN ('G2P','Semantic','Morphology','Embedding','Phonology','Pipeline')),
  created_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP)
);

CREATE TABLE UsageExamples (
  example_id INTEGER PRIMARY KEY,
  definition_id INTEGER NOT NULL,
  example_text TEXT NOT NULL CHECK(length(example_text) BETWEEN 20 AND 2000),
  source_corpus TEXT,
  source_author TEXT,
  source_date TEXT,
  notes TEXT,
  created_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP),
  updated_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP),
  FOREIGN KEY (definition_id) REFERENCES Definitions(definition_id) ON DELETE CASCADE
);

CREATE TABLE Variants (
  variant_id INTEGER PRIMARY KEY,
  word_id INTEGER NOT NULL,
  variant_num INTEGER NOT NULL CHECK(variant_num >= 1),
  phonetic_transcription TEXT NOT NULL CHECK(length(phonetic_transcription) > 0),
  is_primary INTEGER NOT NULL DEFAULT 0 CHECK(is_primary IN (0, 1)),
  dialect_id INTEGER,
  region_id INTEGER,
  created_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP),
  updated_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP), arpabet TEXT, arpabet_source TEXT, arpabet_confidence REAL DEFAULT 0.0, stress_pattern TEXT, syllable_count INTEGER,
  UNIQUE (word_id, variant_num) ON CONFLICT ABORT,
  FOREIGN KEY (word_id) REFERENCES Words(word_id) ON DELETE CASCADE,
  FOREIGN KEY (dialect_id) REFERENCES Dialects(dialect_id) ON DELETE SET NULL,
  FOREIGN KEY (region_id) REFERENCES Regions(region_id) ON DELETE SET NULL
);

CREATE TABLE WordEmbeddings (
  word_id INTEGER NOT NULL,
  model_id INTEGER NOT NULL,
  vector_blob BLOB NOT NULL,
  norm REAL,
  quantization TEXT CHECK(quantization IN ('none','fp16','int8','pq')) DEFAULT 'none',
  is_active INTEGER NOT NULL DEFAULT 1 CHECK(is_active IN (0, 1)),
  created_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP),
  PRIMARY KEY (word_id, model_id) ON CONFLICT REPLACE,
  FOREIGN KEY (word_id) REFERENCES Words(word_id) ON DELETE CASCADE,
  FOREIGN KEY (model_id) REFERENCES EmbeddingModels(model_id) ON DELETE RESTRICT
);

CREATE TABLE WordPhonemes (
  variant_id INTEGER NOT NULL,
  sequence_order INTEGER NOT NULL CHECK(sequence_order >= 0),
  phoneme_id INTEGER NOT NULL,
  is_syllable_boundary INTEGER NOT NULL DEFAULT 0 CHECK(is_syllable_boundary IN (0, 1)),
  stress_level INTEGER CHECK(stress_level BETWEEN 0 AND 3),
  PRIMARY KEY (variant_id, sequence_order) ON CONFLICT ABORT,
  FOREIGN KEY (variant_id) REFERENCES Variants(variant_id) ON DELETE CASCADE,
  FOREIGN KEY (phoneme_id) REFERENCES Phonemes(phoneme_id) ON DELETE RESTRICT
) WITHOUT ROWID;

CREATE TABLE Words (
  word_id INTEGER PRIMARY KEY,
  word TEXT NOT NULL COLLATE NOCASE,
  part_of_speech INTEGER NOT NULL,
  language_id INTEGER NOT NULL,
  is_active INTEGER NOT NULL DEFAULT 1 CHECK(is_active IN (0, 1)),
  is_compound INTEGER NOT NULL DEFAULT 0 CHECK(is_compound IN (0, 1)),
  register_id INTEGER,
  etymology TEXT,
  created_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP),
  updated_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP), frequency REAL DEFAULT 1.0, length INTEGER,
  UNIQUE (word, part_of_speech, language_id) ON CONFLICT ABORT,
  FOREIGN KEY (part_of_speech) REFERENCES PartOfSpeech(pos_id) ON DELETE RESTRICT,
  FOREIGN KEY (language_id) REFERENCES Languages(language_id) ON DELETE RESTRICT,
  FOREIGN KEY (register_id) REFERENCES RegisterTypes(register_id) ON DELETE SET NULL
);

CREATE TABLE heteronym_groups (
                group_id TEXT PRIMARY KEY,
                word TEXT NOT NULL COLLATE NOCASE,
                variant_count INTEGER NOT NULL CHECK(variant_count >= 2),
                created_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP)
            );

CREATE TABLE heteronym_pronunciations (
                pronunciation_id INTEGER PRIMARY KEY AUTOINCREMENT,
                group_id TEXT NOT NULL,
                word TEXT NOT NULL COLLATE NOCASE,
                sense_id INTEGER,
                ipa TEXT NOT NULL CHECK(length(ipa) > 0),
                arpabet TEXT NOT NULL CHECK(length(arpabet) > 0),
                part_of_speech TEXT DEFAULT 'unknown',
                dialect_tag TEXT DEFAULT 'US',
                frequency_score REAL DEFAULT 0.0 CHECK(frequency_score >= 0.0),
                is_primary INTEGER DEFAULT 0 CHECK(is_primary IN (0, 1)),
                confidence_score REAL DEFAULT 1.0 CHECK(confidence_score BETWEEN 0 AND 1),
                notes TEXT,
                created_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP),
                FOREIGN KEY (group_id) REFERENCES heteronym_groups(group_id) ON DELETE CASCADE,
                FOREIGN KEY (sense_id) REFERENCES Senses(sense_id),
                UNIQUE (group_id, sense_id)
            );

CREATE TABLE kernel_schema_versions (
                schema_name TEXT PRIMARY KEY,
                schema_version TEXT NOT NULL,
                updated_at TEXT NOT NULL
            );


-- ---- INDEXS ----

CREATE INDEX idx_ant_cache_word ON AntonymCache(word_id);

CREATE INDEX idx_definitions_sense ON Definitions(sense_id);

CREATE INDEX idx_examples_definition ON UsageExamples(definition_id);

CREATE INDEX idx_features_group ON DistinctiveFeatures(feature_group);

CREATE INDEX idx_g2p_variant ON G2PAlignments(variant_id);

CREATE INDEX idx_heteronym_groups_word
            ON heteronym_groups(word COLLATE NOCASE);

CREATE INDEX idx_heteronym_pronunciations_pos
            ON heteronym_pronunciations(part_of_speech)
            WHERE part_of_speech IS NOT NULL AND part_of_speech != 'unknown';

CREATE INDEX idx_heteronym_pronunciations_primary
            ON heteronym_pronunciations(word, is_primary)
            WHERE is_primary = 1;

CREATE INDEX idx_heteronym_pronunciations_sense
            ON heteronym_pronunciations(sense_id)
            WHERE sense_id IS NOT NULL;

CREATE INDEX idx_heteronym_pronunciations_word
            ON heteronym_pronunciations(word COLLATE NOCASE);

CREATE INDEX idx_pfv_feature ON PhonemeFeatureValues(feature_id);

CREATE INDEX idx_phonemes_category ON Phonemes(category_id);

CREATE INDEX idx_phonemes_language ON Phonemes(language_id);

CREATE UNIQUE INDEX idx_primary_variant ON Variants(word_id) WHERE is_primary = 1;

CREATE INDEX idx_semrel_source ON SemanticRelationships(source_word_id);

CREATE INDEX idx_semrel_target ON SemanticRelationships(target_word_id);

CREATE INDEX idx_semrel_type ON SemanticRelationships(type_id);

CREATE INDEX idx_senseemb_model ON SenseEmbeddings(model_id);

CREATE INDEX idx_syn_cache_word ON SynonymCache(word_id);

CREATE INDEX idx_variants_dialect ON Variants(dialect_id);

CREATE INDEX idx_variants_region ON Variants(region_id);

CREATE INDEX idx_variants_word ON Variants(word_id);

CREATE INDEX idx_wordemb_model ON WordEmbeddings(model_id);

CREATE INDEX idx_wordphonemes_phoneme ON WordPhonemes(phoneme_id);

CREATE INDEX idx_words_active ON Words(is_active);

CREATE INDEX idx_words_language ON Words(language_id);

CREATE INDEX idx_words_lemma ON Words(word, part_of_speech);

CREATE INDEX idx_words_pos ON Words(part_of_speech);

CREATE UNIQUE INDEX ux_semrel_unique ON SemanticRelationships(
  source_word_id,
  target_word_id,
  type_id,
  COALESCE(source_definition_id, -1),
  COALESCE(target_definition_id, -1)
);


-- ---- TRIGGERS ----

CREATE TRIGGER definitions_update_timestamp AFTER UPDATE ON Definitions
BEGIN
  UPDATE Definitions SET updated_at = CURRENT_TIMESTAMP WHERE definition_id = NEW.definition_id;
END;

CREATE TRIGGER g2p_validate_bi BEFORE INSERT ON G2PAlignments
BEGIN
  SELECT CASE
    WHEN (NEW.grapheme_start_index + NEW.grapheme_length) > (
      SELECT length(w.word)
      FROM Words w
      JOIN Variants v ON v.word_id = w.word_id
      WHERE v.variant_id = NEW.variant_id
    )
    THEN RAISE(ABORT, 'Invalid G2P grapheme span (out of bounds)')
  END;

  SELECT CASE
    WHEN NEW.phoneme_seq_len > 0 AND (
      SELECT max(sequence_order) FROM WordPhonemes WHERE variant_id = NEW.variant_id
    ) IS NULL
    THEN RAISE(ABORT, 'Invalid G2P phoneme span (no WordPhonemes for variant)')
  END;

  SELECT CASE
    WHEN NEW.phoneme_seq_len > 0 AND (
      NEW.phoneme_seq_start + NEW.phoneme_seq_len - 1
    ) > (
      SELECT max(sequence_order) FROM WordPhonemes WHERE variant_id = NEW.variant_id
    )
    THEN RAISE(ABORT, 'Invalid G2P phoneme span (out of bounds)')
  END;

  SELECT CASE
    WHEN NEW.phoneme_seq_len > 0 AND (
      SELECT count(*)
      FROM WordPhonemes
      WHERE variant_id = NEW.variant_id
        AND sequence_order BETWEEN NEW.phoneme_seq_start AND (NEW.phoneme_seq_start + NEW.phoneme_seq_len - 1)
    ) != NEW.phoneme_seq_len
    THEN RAISE(ABORT, 'Invalid G2P phoneme span (non-contiguous or missing sequence orders)')
  END;
END;

CREATE TRIGGER phonemes_validate_ipa_bi BEFORE INSERT ON Phonemes
BEGIN
  SELECT CASE
    WHEN EXISTS (
      WITH RECURSIVE chars(i, ch) AS (
        SELECT 1, substr(NEW.ipa_symbol, 1, 1)
        UNION ALL
        SELECT i+1, substr(NEW.ipa_symbol, i+1, 1)
        FROM chars
        WHERE i < length(NEW.ipa_symbol)
      )
      SELECT 1
      FROM chars
      WHERE ch IS NOT NULL AND ch != ''
        AND NOT EXISTS (SELECT 1 FROM IpaAllowedChars a WHERE a.ch = chars.ch)
    )
    THEN RAISE(ABORT, 'Invalid IPA character in Phonemes.ipa_symbol')
  END;
END;

CREATE TRIGGER semantic_bidirectional_delete AFTER DELETE ON SemanticRelationships
WHEN OLD.bidirectional = 1
BEGIN
  DELETE FROM SemanticRelationships
  WHERE source_word_id = OLD.target_word_id
    AND target_word_id = OLD.source_word_id
    AND type_id = OLD.type_id
    AND COALESCE(source_definition_id, -1) = COALESCE(OLD.target_definition_id, -1)
    AND COALESCE(target_definition_id, -1) = COALESCE(OLD.source_definition_id, -1);
END;

CREATE TRIGGER semantic_bidirectional_insert AFTER INSERT ON SemanticRelationships
WHEN NEW.bidirectional = 1
BEGIN
  INSERT OR IGNORE INTO SemanticRelationships (
    source_word_id, target_word_id, type_id, bidirectional,
    definition_specific, source_definition_id, target_definition_id, confidence, metadata
  )
  VALUES (
    NEW.target_word_id, NEW.source_word_id, NEW.type_id, 1,
    NEW.definition_specific, NEW.target_definition_id, NEW.source_definition_id, NEW.confidence, NEW.metadata
  );
END;

CREATE TRIGGER semantic_cache_ad AFTER DELETE ON SemanticRelationships
BEGIN
  DELETE FROM SynonymCache WHERE relationship_id = OLD.relationship_id;
  DELETE FROM AntonymCache WHERE relationship_id = OLD.relationship_id;
END;

CREATE TRIGGER semantic_cache_ai AFTER INSERT ON SemanticRelationships
BEGIN
  INSERT OR REPLACE INTO SynonymCache(relationship_id, word_id, synonym_word_id, definition_id, synonym_definition_id, confidence, metadata)
  SELECT NEW.relationship_id, NEW.source_word_id, NEW.target_word_id, NEW.source_definition_id, NEW.target_definition_id, NEW.confidence, NEW.metadata
  WHERE NEW.type_id = (SELECT type_id FROM SemanticRelationshipTypes WHERE type_name='synonym');

  INSERT OR REPLACE INTO AntonymCache(relationship_id, word_id, antonym_word_id, definition_id, antonym_definition_id, confidence, metadata)
  SELECT NEW.relationship_id, NEW.source_word_id, NEW.target_word_id, NEW.source_definition_id, NEW.target_definition_id, NEW.confidence, NEW.metadata
  WHERE NEW.type_id = (SELECT type_id FROM SemanticRelationshipTypes WHERE type_name='antonym');
END;

CREATE TRIGGER semantic_cache_au AFTER UPDATE ON SemanticRelationships
BEGIN
  DELETE FROM SynonymCache WHERE relationship_id = OLD.relationship_id;
  DELETE FROM AntonymCache WHERE relationship_id = OLD.relationship_id;

  INSERT OR REPLACE INTO SynonymCache(relationship_id, word_id, synonym_word_id, definition_id, synonym_definition_id, confidence, metadata)
  SELECT NEW.relationship_id, NEW.source_word_id, NEW.target_word_id, NEW.source_definition_id, NEW.target_definition_id, NEW.confidence, NEW.metadata
  WHERE NEW.type_id = (SELECT type_id FROM SemanticRelationshipTypes WHERE type_name='synonym');

  INSERT OR REPLACE INTO AntonymCache(relationship_id, word_id, antonym_word_id, definition_id, antonym_definition_id, confidence, metadata)
  SELECT NEW.relationship_id, NEW.source_word_id, NEW.target_word_id, NEW.source_definition_id, NEW.target_definition_id, NEW.confidence, NEW.metadata
  WHERE NEW.type_id = (SELECT type_id FROM SemanticRelationshipTypes WHERE type_name='antonym');
END;

CREATE TRIGGER variants_primary_check_bi BEFORE INSERT ON Variants
WHEN NEW.is_primary = 1
BEGIN
  UPDATE Variants SET is_primary = 0 WHERE word_id = NEW.word_id AND is_primary = 1;
END;

CREATE TRIGGER variants_primary_check_bu BEFORE UPDATE OF is_primary ON Variants
WHEN NEW.is_primary = 1 AND OLD.is_primary = 0
BEGIN
  UPDATE Variants
  SET is_primary = 0
  WHERE word_id = NEW.word_id
    AND variant_id != NEW.variant_id
    AND is_primary = 1;
END;

CREATE TRIGGER variants_update_timestamp AFTER UPDATE ON Variants
BEGIN
  UPDATE Variants SET updated_at = CURRENT_TIMESTAMP WHERE variant_id = NEW.variant_id;
END;

CREATE TRIGGER variants_validate_ipa_bi BEFORE INSERT ON Variants
BEGIN
  SELECT CASE
    WHEN EXISTS (
      WITH RECURSIVE chars(i, ch) AS (
        SELECT 1, substr(NEW.phonetic_transcription, 1, 1)
        UNION ALL
        SELECT i+1, substr(NEW.phonetic_transcription, i+1, 1)
        FROM chars
        WHERE i < length(NEW.phonetic_transcription)
      )
      SELECT 1
      FROM chars
      WHERE ch IS NOT NULL AND ch != ''
        AND NOT EXISTS (SELECT 1 FROM IpaAllowedChars a WHERE a.ch = chars.ch)
    )
    THEN RAISE(ABORT, 'Invalid IPA character in Variants.phonetic_transcription')
  END;
END;

CREATE TRIGGER variants_validate_ipa_bu BEFORE UPDATE OF phonetic_transcription ON Variants
BEGIN
  SELECT CASE
    WHEN EXISTS (
      WITH RECURSIVE chars(i, ch) AS (
        SELECT 1, substr(NEW.phonetic_transcription, 1, 1)
        UNION ALL
        SELECT i+1, substr(NEW.phonetic_transcription, i+1, 1)
        FROM chars
        WHERE i < length(NEW.phonetic_transcription)
      )
      SELECT 1
      FROM chars
      WHERE ch IS NOT NULL AND ch != ''
        AND NOT EXISTS (SELECT 1 FROM IpaAllowedChars a WHERE a.ch = chars.ch)
    )
    THEN RAISE(ABORT, 'Invalid IPA character in Variants.phonetic_transcription')
  END;
END;

CREATE TRIGGER words_update_timestamp AFTER UPDATE ON Words
BEGIN
  UPDATE Words SET updated_at = CURRENT_TIMESTAMP WHERE word_id = NEW.word_id;
END;


-- ---- VIEWS ----

CREATE VIEW POSLookup AS
        SELECT pos_id, pos_abbreviation AS abbreviation, pos_name, description
        FROM PartOfSpeech
        WHERE is_active = 1;

CREATE VIEW PhonemeFeatureVector AS
SELECT pfv.phoneme_id, df.feature_name, pfv.value_num
FROM PhonemeFeatureValues pfv
JOIN DistinctiveFeatures df ON df.feature_id = pfv.feature_id;

CREATE VIEW Pronunciations AS SELECT v.variant_id AS id, w.word_id AS word_id, v.arpabet, v.phonetic_transcription AS ipa, v.syllable_count, v.stress_pattern, v.is_primary, COALESCE(v.dialect_id, 1) AS dialect_code, COALESCE(v.arpabet_confidence, 1.0) AS confidence, COALESCE(v.arpabet_source, 'LEXICON') AS source FROM Variants v JOIN Words w ON v.word_id = w.word_id WHERE v.arpabet IS NOT NULL AND v.arpabet != '';

CREATE VIEW unique_pronunciations AS
        SELECT
            w.word,
            trim(v.arpabet) AS arpabet,
            MIN(v.variant_id) AS variant_id,
            MIN(v.phonetic_transcription) AS ipa,
            MIN(v.syllable_count) AS syllable_count,
            MIN(v.stress_pattern) AS stress_pattern
        FROM Variants v
        JOIN Words w ON v.word_id = w.word_id
        WHERE v.arpabet IS NOT NULL AND trim(v.arpabet) != ''
        GROUP BY w.word, trim(v.arpabet);

CREATE VIEW v_AntonymLists AS
SELECT
  y.word_id,
  y.word,
  y.antonyms,
  y.antonym_count,
  y.avg_confidence
FROM (
  SELECT
    w.word_id,
    w.word,
    group_concat(w2.word, ', ')
      OVER (
        PARTITION BY w.word_id
        ORDER BY w2.word
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
      ) AS antonyms,
    COUNT(*) OVER (PARTITION BY w.word_id) AS antonym_count,
    AVG(ac.confidence) OVER (PARTITION BY w.word_id) AS avg_confidence,
    ROW_NUMBER() OVER (PARTITION BY w.word_id ORDER BY w2.word DESC) AS rn
  FROM Words w
  JOIN AntonymCache ac ON ac.word_id = w.word_id
  JOIN Words w2 ON w2.word_id = ac.antonym_word_id
  WHERE w.is_active = 1 AND w2.is_active = 1
) AS y
WHERE y.rn = 1;

CREATE VIEW v_DialectLanguageMismatch AS
SELECT v.variant_id, w.word, d.dialect_code, l.language_code AS word_language
FROM Variants v
JOIN Words w ON w.word_id = v.word_id
JOIN Dialects d ON d.dialect_id = v.dialect_id
JOIN Languages l ON l.language_id = w.language_id
WHERE d.language_id != w.language_id;

CREATE VIEW v_G2PAlignmentOutOfRange AS
WITH pc AS (
  SELECT variant_id, COUNT(*) AS phoneme_count
  FROM WordPhonemes
  GROUP BY variant_id
)
SELECT
  a.alignment_id,
  w.word,
  a.variant_id,
  a.phoneme_seq_start,
  a.phoneme_seq_len,
  pc.phoneme_count
FROM G2PAlignments a
JOIN Variants v ON v.variant_id = a.variant_id
JOIN Words w ON w.word_id = v.word_id
JOIN pc ON pc.variant_id = a.variant_id
WHERE a.phoneme_seq_start IS NOT NULL
  AND (a.phoneme_seq_start + a.phoneme_seq_len) > pc.phoneme_count;

CREATE VIEW v_InvalidG2PAlignments AS
SELECT a.alignment_id, w.word, a.grapheme_start_index, a.grapheme_length, a.phoneme_seq_start, a.phoneme_seq_len
FROM G2PAlignments a
JOIN Variants v ON v.variant_id = a.variant_id
JOIN Words w ON w.word_id = v.word_id
WHERE (a.grapheme_start_index + a.grapheme_length) > length(w.word)
   OR (a.phoneme_seq_len > 0 AND (
        a.phoneme_seq_start + a.phoneme_seq_len - 1
      ) > (SELECT max(sequence_order) FROM WordPhonemes wp WHERE wp.variant_id = a.variant_id));

CREATE VIEW v_MissingWordEmbeddings AS
SELECT w.word_id, w.word, em.model_name
FROM Words w
JOIN EmbeddingModels em ON em.is_active = 1
WHERE w.is_active = 1
  AND NOT EXISTS (
    SELECT 1 FROM WordEmbeddings we
    WHERE we.word_id = w.word_id AND we.model_id = em.model_id AND we.is_active = 1
  );

CREATE VIEW v_OrphanedPhonemes AS
SELECT p.phoneme_id, p.ipa_symbol
FROM Phonemes p
WHERE NOT EXISTS (SELECT 1 FROM WordPhonemes wp WHERE wp.phoneme_id = p.phoneme_id);

CREATE VIEW v_PrimaryStress AS
SELECT 
  v.variant_id,
  w.word_id,
  w.word,
  MIN(CASE WHEN wp.stress_level = 1 THEN wp.sequence_order + 1 END) AS primary_stress_position,
  COUNT(CASE WHEN wp.stress_level = 1 THEN 1 END) AS num_primary_stress,
  CASE 
    WHEN MIN(CASE WHEN wp.stress_level = 1 THEN wp.sequence_order END) = MIN(wp.sequence_order)
    THEN 1 ELSE 0
  END AS has_initial_stress,
  CASE 
    WHEN MAX(CASE WHEN wp.stress_level = 1 THEN wp.sequence_order END) = MAX(wp.sequence_order)
    THEN 1 ELSE 0
  END AS has_final_stress
FROM Variants v
JOIN Words w ON w.word_id = v.word_id
JOIN WordPhonemes wp ON wp.variant_id = v.variant_id
WHERE w.is_active = 1
GROUP BY v.variant_id, w.word_id, w.word;

CREATE VIEW v_ReleaseGateFailures AS
SELECT 'integrity_words_missing_primary_variant' AS check_name, COUNT(*) AS n_rows
FROM v_WordsMissingPrimaryVariant
HAVING COUNT(*) > 0
UNION ALL
SELECT 'integrity_orphaned_phonemes', COUNT(*)
FROM v_OrphanedPhonemes
HAVING COUNT(*) > 0
UNION ALL
SELECT 'integrity_invalid_g2p_alignments', COUNT(*)
FROM v_InvalidG2PAlignments
HAVING COUNT(*) > 0
UNION ALL
SELECT 'integrity_g2p_alignment_out_of_range', COUNT(*)
FROM v_G2PAlignmentOutOfRange
HAVING COUNT(*) > 0
UNION ALL
SELECT 'integrity_wordphoneme_sequence_gaps', COUNT(*)
FROM v_WordPhonemeSequenceGaps
HAVING COUNT(*) > 0
UNION ALL
SELECT 'integrity_semantic_bidirectional_broken', COUNT(*)
FROM v_SemanticBidirectionalBroken
HAVING COUNT(*) > 0
UNION ALL
SELECT 'integrity_synonym_cache_mismatch', COUNT(*)
FROM v_SynonymCacheMismatch
HAVING COUNT(*) > 0
UNION ALL
SELECT 'integrity_dialect_language_mismatch', COUNT(*)
FROM v_DialectLanguageMismatch
HAVING COUNT(*) > 0
UNION ALL
SELECT 'integrity_semantic_relationship_cycles', COUNT(*)
FROM v_SemanticRelationshipCycles
HAVING COUNT(*) > 0;

CREATE VIEW v_RhymeFinder AS
SELECT
  w1.word_id AS word1_id,
  w1.word AS word1,
  w2.word_id AS word2_id,
  w2.word AS word2,
  sp1.stress_pattern AS word1_stress,
  sp2.stress_pattern AS word2_stress,
  CASE WHEN sp1.stress_pattern = sp2.stress_pattern THEN 1 ELSE 0 END AS same_stress,
  v1.phonetic_transcription AS word1_phonetics,
  v2.phonetic_transcription AS word2_phonetics,
  substr(v1.phonetic_transcription, -3) AS word1_ending,
  substr(v2.phonetic_transcription, -3) AS word2_ending
FROM Words w1
JOIN Variants v1 ON v1.word_id = w1.word_id AND v1.is_primary = 1
LEFT JOIN v_StressPatterns sp1 ON sp1.variant_id = v1.variant_id
JOIN Words w2 ON w2.word_id != w1.word_id
JOIN Variants v2 ON v2.word_id = w2.word_id AND v2.is_primary = 1
LEFT JOIN v_StressPatterns sp2 ON sp2.variant_id = v2.variant_id
WHERE w1.is_active = 1 AND w2.is_active = 1
  AND substr(v1.phonetic_transcription, -3) = substr(v2.phonetic_transcription, -3);

CREATE VIEW v_SecondaryStress AS
SELECT 
  v.variant_id,
  w.word_id,
  w.word,
  MIN(CASE WHEN wp.stress_level = 2 THEN wp.sequence_order + 1 END) AS secondary_stress_position,
  COUNT(CASE WHEN wp.stress_level = 2 THEN 1 END) AS num_secondary_stress
FROM Variants v
JOIN Words w ON w.word_id = v.word_id
JOIN WordPhonemes wp ON wp.variant_id = v.variant_id
WHERE w.is_active = 1
GROUP BY v.variant_id, w.word_id, w.word;

CREATE VIEW v_SemanticBidirectionalBroken AS
SELECT sr.relationship_id, sr.source_word_id, sr.target_word_id, sr.type_id
FROM SemanticRelationships sr
WHERE sr.bidirectional = 1
  AND NOT EXISTS (
    SELECT 1 FROM SemanticRelationships sr2
    WHERE sr2.source_word_id = sr.target_word_id
      AND sr2.target_word_id = sr.source_word_id
      AND sr2.type_id = sr.type_id
      AND COALESCE(sr2.source_definition_id, -1) = COALESCE(sr.target_definition_id, -1)
      AND COALESCE(sr2.target_definition_id, -1) = COALESCE(sr.source_definition_id, -1)
  );

CREATE VIEW v_SemanticRelationshipCycles AS
WITH RECURSIVE paths(source_id, target_id, type_id, depth, path) AS (
  -- Base case: all bidirectional relationships
  SELECT
    source_word_id AS source_id,
    target_word_id AS target_id,
    type_id,
    1 AS depth,
    CAST(source_word_id AS TEXT) || '->' || CAST(target_word_id AS TEXT) AS path
  FROM SemanticRelationships
  WHERE bidirectional = 1

  UNION ALL

  -- Recursive case: follow bidirectional relationships
  SELECT
    p.source_id,
    sr.target_word_id AS target_id,
    sr.type_id,
    p.depth + 1,
    p.path || '->' || CAST(sr.target_word_id AS TEXT) AS path
  FROM paths p
  JOIN SemanticRelationships sr
    ON sr.source_word_id = p.target_id
    AND sr.type_id = p.type_id
    AND sr.bidirectional = 1
  WHERE p.depth < 10  -- Prevent infinite recursion (max cycle depth = 10)
    AND p.source_id != sr.target_word_id  -- Don't count self-loops in path
)
SELECT DISTINCT
  source_id,
  target_id,
  type_id,
  depth,
  path || '->' || CAST(source_id AS TEXT) AS cycle_path
FROM paths
WHERE target_id = source_id  -- Found a cycle back to origin
  AND depth > 1;

CREATE VIEW v_StressPatterns AS
SELECT
  x.variant_id,
  x.word_id,
  x.word,
  x.stress_pattern,
  x.phoneme_count,
  x.syllable_count
FROM (
  SELECT
    v.variant_id,
    w.word_id,
    w.word,
    group_concat(COALESCE(CAST(wp.stress_level AS TEXT), '0'), '')
      OVER (
        PARTITION BY v.variant_id
        ORDER BY wp.sequence_order
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
      ) AS stress_pattern,
    COUNT(*) OVER (PARTITION BY v.variant_id) AS phoneme_count,
    SUM(CASE WHEN wp.stress_level IS NOT NULL THEN 1 ELSE 0 END)
      OVER (PARTITION BY v.variant_id) AS syllable_count,
    ROW_NUMBER() OVER (PARTITION BY v.variant_id ORDER BY wp.sequence_order DESC) AS rn
  FROM Variants v
  JOIN Words w ON w.word_id = v.word_id
  JOIN WordPhonemes wp ON wp.variant_id = v.variant_id
  WHERE w.is_active = 1
) AS x
WHERE x.rn = 1;

CREATE VIEW v_StressPositions AS
SELECT
  sp.variant_id,
  sp.word_id,
  sp.word,
  ps.primary_stress_position,
  ps.num_primary_stress,
  ps.has_initial_stress,
  ps.has_final_stress,
  ss.secondary_stress_position,
  ss.num_secondary_stress,
  sp.stress_pattern,
  sp.syllable_count
FROM v_StressPatterns sp
LEFT JOIN v_PrimaryStress ps ON ps.variant_id = sp.variant_id
LEFT JOIN v_SecondaryStress ss ON ss.variant_id = sp.variant_id;

CREATE VIEW v_SynonymCacheMismatch AS
SELECT sr.relationship_id
FROM SemanticRelationships sr
JOIN SemanticRelationshipTypes t ON t.type_id = sr.type_id AND t.type_name='synonym'
LEFT JOIN SynonymCache sc ON sc.relationship_id = sr.relationship_id
WHERE sc.relationship_id IS NULL;

CREATE VIEW v_SynonymLists AS
SELECT
  y.word_id,
  y.word,
  y.synonyms,
  y.synonym_count,
  y.avg_confidence
FROM (
  SELECT
    w.word_id,
    w.word,
    group_concat(w2.word, ', ')
      OVER (
        PARTITION BY w.word_id
        ORDER BY w2.word
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
      ) AS synonyms,
    COUNT(*) OVER (PARTITION BY w.word_id) AS synonym_count,
    AVG(sc.confidence) OVER (PARTITION BY w.word_id) AS avg_confidence,
    ROW_NUMBER() OVER (PARTITION BY w.word_id ORDER BY w2.word DESC) AS rn
  FROM Words w
  JOIN SynonymCache sc ON sc.word_id = w.word_id
  JOIN Words w2 ON w2.word_id = sc.synonym_word_id
  WHERE w.is_active = 1 AND w2.is_active = 1
) AS y
WHERE y.rn = 1;

CREATE VIEW v_TestRunSummary AS
SELECT
  tr.run_id,
  tr.suite_id,
  ts.suite_name,
  tr.started_at,
  tr.finished_at,
  tr.environment,
  tr.git_sha,
  tr.runner,
  tr.pass_rate,
  (SELECT COUNT(*) FROM TestCaseResults r WHERE r.run_id = tr.run_id) AS n_results,
  (SELECT SUM(CASE WHEN r.passed=1 THEN 1 ELSE 0 END) FROM TestCaseResults r WHERE r.run_id = tr.run_id) AS n_passed
FROM TestRuns tr
JOIN TestSuites ts ON ts.suite_id = tr.suite_id;

CREATE VIEW v_WordComplete AS
SELECT 
  w.word_id,
  w.word,
  w.part_of_speech,
  pos.pos_name,
  pos.pos_abbreviation,
  l.language_name,
  l.language_code,
  v.variant_id,
  v.phonetic_transcription,
  v.is_primary,
  sp.stress_pattern,
  sp.syllable_count,
  ps.primary_stress_position,
  ps.has_initial_stress,
  ps.has_final_stress,
  ss.secondary_stress_position,
  ss.num_secondary_stress,
  sl.synonyms,
  sl.synonym_count,
  al.antonyms,
  al.antonym_count,
  r.register_name,
  w.is_compound,
  w.created_at,
  w.updated_at
FROM Words w
JOIN PartOfSpeech pos ON pos.pos_id = w.part_of_speech
JOIN Languages l ON l.language_id = w.language_id
LEFT JOIN Variants v ON v.word_id = w.word_id AND v.is_primary = 1
LEFT JOIN v_StressPatterns sp ON sp.variant_id = v.variant_id
LEFT JOIN v_PrimaryStress ps ON ps.variant_id = v.variant_id
LEFT JOIN v_SecondaryStress ss ON ss.variant_id = v.variant_id
LEFT JOIN v_SynonymLists sl ON sl.word_id = w.word_id
LEFT JOIN v_AntonymLists al ON al.word_id = w.word_id
LEFT JOIN RegisterTypes r ON r.register_id = w.register_id
WHERE w.is_active = 1;

CREATE VIEW v_WordPhonemeSequenceGaps AS
WITH seq AS (
  SELECT
    variant_id,
    sequence_order,
    LAG(sequence_order) OVER (PARTITION BY variant_id ORDER BY sequence_order) AS prev_seq
  FROM WordPhonemes
),
gaps AS (
  SELECT variant_id, sequence_order, prev_seq
  FROM seq
  WHERE prev_seq IS NOT NULL AND sequence_order != prev_seq + 1
)
SELECT
  g.variant_id,
  w.word,
  g.prev_seq AS prev_sequence_order,
  g.sequence_order AS sequence_order
FROM gaps g
JOIN Variants v ON v.variant_id = g.variant_id
JOIN Words w ON w.word_id = v.word_id;

CREATE VIEW v_WordsMissingPrimaryVariant AS
SELECT w.word_id, w.word, w.language_id
FROM Words w
WHERE NOT EXISTS (SELECT 1 FROM Variants v WHERE v.word_id = w.word_id AND v.is_primary = 1);

